# -*- coding: utf-8 -*-
"""Face Emotions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z8Z5KL1jkM1JlXsi6PguqOQkQrP676oA
"""

from sklearn.preprocessing import LabelEncoder
import numpy as np
import cv2
import os
from sklearn.model_selection import train_test_split
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.models import Sequential
import tensorflow as tf
from google.colab import drive
drive.mount('/content/drive')


# Define and load dataset
dataset_dir = '/content/drive/MyDrive/Colab Notebooks/dataset.zip'


# Path to the directory containing the extracted dataset
dataset_dir = '/content/dataset'

# List of emotion categories (folder names)
emotion_categories = os.listdir(dataset_dir)

# Lists to store images and their corresponding labels
images = []
labels = []

# Iterate over each emotion category
for category in emotion_categories:
    # Path to the folder containing images for the current emotion category
    category_dir = os.path.join(dataset_dir, category)

    # List all image files in the current folder
    image_files = os.listdir(category_dir)

    # Loop through each image file
    for image_file in image_files:
        # Load the image using OpenCV
        image_path = os.path.join(category_dir, image_file)
        # Load image in grayscale
        image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

        # Append the image and its corresponding label to the lists
        images.append(image)
        labels.append(category)

# Convert lists to NumPy arrays
images = np.array(images)
labels = np.array(labels)

# Split the dataset into train, validation, and test sets
train_images, test_images, train_labels, test_labels = train_test_split(
    images, labels, test_size=0.2, random_state=42)
train_images, val_images, train_labels, val_labels = train_test_split(
    train_images, train_labels, test_size=0.1, random_state=42)

# Print shapes to verify
print("Train images shape:", train_images.shape)
print("Train labels shape:", train_labels.shape)
print("Validation images shape:", val_images.shape)
print("Validation labels shape:", val_labels.shape)
print("Test images shape:", test_images.shape)
print("Test labels shape:", test_labels.shape)

# Define your model architecture
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(48, 48, 1)),
    MaxPooling2D((2, 2)),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Conv2D(128, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(7, activation='softmax')  # 7 classes for different emotions
])

# Compile the model
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# Initialize LabelEncoder
label_encoder = LabelEncoder()

# Convert string labels to numerical format
train_labels_encoded = label_encoder.fit_transform(train_labels)
val_labels_encoded = label_encoder.fit_transform(val_labels)

# Train the model
model.fit(train_images, train_labels_encoded, epochs=10,
          validation_data=(val_images, val_labels_encoded))

# Initialize the encoder
label_encoder = LabelEncoder()

# Fit and transform labels
test_labels_encoded = label_encoder.fit_transform(test_labels)

# Evaluate the model
test_loss, test_acc = model.evaluate(test_images, test_labels_encoded)
print('Test accuracy:', test_acc)

# Save the model in the native Keras format
model.save('emotion_recognition_model.keras')

# Save the model
# model.save('emotion_recognition_model.h5')
